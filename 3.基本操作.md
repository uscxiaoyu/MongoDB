## 1.创建数据库
MongoDB 创建数据库的语法格式如下：
```javascript
use <db_name>
```


如果数据库不存在，则新建名称为db_name的数据库，否则切换至db_name数据库。

<B> 示例１：创建名称为mdb_test的数据库。</B>
```javascript
> use mdb_test
switched to db mdb_test
> db
mdb_test

```
如果你想查看所有数据库，可以使用 show dbs 命令：
```javascript
> show dbs
admin   0.000GB
local   0.000GB

```
我们刚创建的数据库mdb_test并不在数据库的列表中，要显示数据库插入一些数据。

<B> 示例2:往md_test中插入一个文档 </B>
```javascript
> db.collec_test.insert({'x':1, 'y':2})
WriteResult({ "nInserted" : 1 })
> show dbs
local   0.078GB
md_test  0.078GB
test    0.078GB
>
```

*注意：(1)不能直接在mongodb数据库中插入一条记录，而是应该在collection当中插入，如例２中的collec_test为一个集合;(2)MongoDB 中默认的数据库为test，如果你没有创建新的数据库，集合将存放在 test 数据库中。*

## 2.删除数据库
MongoDB 删除数据库的语法格式如下：
```javascript
db.dropDatabase()
```
<B> 示例3: 删除数据库md_test </B>
```javascript
> use mdb_test　　//选定需删除的数据库
switched to db mdb_test
> db.dropDatabase()
{ "dropped" : "mdb_test", "ok" : 1 }
> show dbs  //查看是否删除成功
local   0.078GB
test    0.078GB
```

## 3.创建集合
MongoDB 中使用 createCollection() 方法来创建集合。
```javascript
db.createCollection(name, options)
```
参数说明：

- name: 要创建的集合名称
- options: 可选参数, 指定有关内存大小及索引的选项.options 可以是如下参数：

| 字段 | 类型     |描述　|
| :------------- | :------------- | :------------- |
| capped      | 布尔       |（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。当该值为 true 时，必须指定 size 参数。 |
| autoIndexId  | 布尔  | （可选）如为 true，自动在 _id 字段创建索引。默认为 false。  |
| size  | 数值  | （可选）为固定集合指定一个最大值（以字节计）。如果 capped 为 true，也需要指定该字段。  |
|max   | 数值  | （可选）指定固定集合中包含文档的最大数量。  |

在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。

<B> 示例４:　在数据库md_test中创建collec_test集合，并查看md_test中的所有集合。 </B>
```javascript
> use mdb_test
switched to db mdb_test
> db.createCollection("collec_test")
{ "ok" : 1 }
> show collections
collec_test
```
下面是带有几个关键参数的 createCollection() 的用法：

创建固定集合 mycol，整个集合空间大小 6142800 KB, 文档最大个数为 10000 个。
```javascript
> db.createCollection("collec_2", {capped:true, size: 6142800, max: 10000})
{ "ok" : 1 }
> show collections
collec_2
collec_test
```
最后，在MongoDB中，其实你并不需要利用以上语法创建集合。当你插入一些文档时，MongoDB 会自动创建集合。
```javascript
> db.collec_3.insert({"s_id":20181212, "s_name":"张小芳"})
WriteResult({ "nInserted" : 1 })
> show collections
collec_2
collec_3
collec_test
>
```

## 4.删除集合
MongoDB 删除集合的语法格式如下：
```javascript
db.<collection_name>.drop()
```
如果成功删除选定集合，则 drop() 方法返回 true，否则返回 false。

<B> 示例5:　删除数据库md_test中的collec_test集合。 </B>
```javascript
> use mdb_test
switched to db mdb_test
> db.collec_test.insert({'x':1, 'y':2})
WriteResult({ "nInserted" : 1 })
> show tables
collec_2
collec_3
collec_test
> db.collec_test.drop()
true
> show tables
collec_2
collec_3
>
```

## 5.插入文档
文档的数据结构和JSON基本一样。所有存储在集合中的数据都是BSON格式。BSON是一种类json的一种二进制形式的存储格式,简称Binary JSON。

#### insert()
MongoDB 可使用 insert() 或 save() 方法向集合中插入文档，语法如下：
```javascript
db.<collection_name>.insert(document)
```
<B> 示例6: 利用insert()和save()分别往mdb_test中的student集合中插入１条记录。</B>
```javascript
> use mdb_test
> db.student.insert({'student_id':2015210315, student_name:'张三丰', gender:'男'})
WriteResult({ "nInserted" : 1 })
> db.student.save({'student_id':2015210316, student_name:'李想', gender:'男'})
WriteResult({ "nInserted" : 1 })
> db.student.find()
> db.student.find()
{ "_id" : ObjectId("5bbff0cb37083a548e8013a2"),
"student_id" : 2015210315, "student_name" : "张三丰", "gender" : "男" }
{ "_id" : ObjectId("5bbff18237083a548e8013a3"),
"student_id" : 2015210316, "student_name" : "李想", "gender" : "男" }
>
```
上例中，文档中元素的基本形式为键值对，键将自动转换为字符串形式，而值为输入的类型。如果没有插入的文档未指定_id，则mongodb将自动生成一个_id。

<B> 示例7:　利用insert()往mdb_test中的student集合中插入1条记录，指定_id。</B>
```javascript
> db.student.insert({'_id':2015210317, student_name:'郭涛', gender:'男'})
WriteResult({ "nInserted" : 1 })
> db.student.find()
{ "_id" : ObjectId("5bbff0cb37083a548e8013a2"),
"student_id" : 2015210315, "student_name" : "张三丰", "gender" : "男" }
{ "_id" : ObjectId("5bbff18237083a548e8013a3"),
"student_id" : 2015210316, "student_name" : "李想", "gender" : "男" }
{ "_id" : 2015210317, "student_name" : "郭涛", "gender" : "男" }
>
```
也可通过insert()1次性插入多条数据的方法。
```javascript
db.<collection_name>.insert([document1, ducument2, ...])
```

<B> 示例8: 删除student集合中的三个文档，然后通过insert()一次插入三个文档。</B>
```javascript
> db.student.drop()
true
> db.student.insert([
    {"student_id" : 2015210315, "student_name" : "张三丰", "gender" : "男"},
    {"student_id" : 2015210316, "student_name" : "李想", "gender" : "男"},
    {"_id" : 2015210317, "student_name" : "郭涛", "gender" : "男"}])
BulkWriteResult({
	"writeErrors" : [ ],
	"writeConcernErrors" : [ ],
	"nInserted" : 3,
	"nUpserted" : 0,
	"nMatched" : 0,
	"nModified" : 0,
	"nRemoved" : 0,
	"upserted" : [ ]
})

> db.student.find()
{ "_id" : ObjectId("5bbff7a937083a548e8013a4"),
"student_id" : 2015210315, "student_name" : "张三丰", "gender" : "男" }
{ "_id" : ObjectId("5bbff7a937083a548e8013a5"),
"student_id" : 2015210316, "student_name" : "李想", "gender" : "男" }
{ "_id" : 2015210317, "student_name" : "郭涛", "gender" : "男" }
```
#### insertone()和insertMany()
MongoDB也又专门用于插入１条和多条记录的方法insertOne()和insertMany()。
```javascript
db.<collection_name>.insertOne(document) //插入１条记录
db.<collection_name>.insertMany([document1, ducument2, ...]) //插入多条记录
```

<B> 示例9: 删除student集合中的三个文档，然后通过insertOne()插入1个文档，利用insertMany()插入2个文档。</B>
```javascript
> db.student.drop()
true
> db.student.insertOne({"student_id" : 2015210315,
    "student_name" : "张三丰", "gender" : "男"})
{
	"acknowledged" : true,
	"insertedId" : ObjectId("5bbffb0437083a548e8013aa")
}
> db.student.insertMany([
    {"student_id" : 2015210316, "student_name" : "李想", "gender" : "男"},
    {"_id" : 2015210317, "student_name" : "郭涛", "gender" : "男"}])
{
	"acknowledged" : true,
	"insertedIds" : [
		ObjectId("5bbffc4d101248fb47295889"),
		2015210317
	]
}
> db.student.find()
{ "_id" : ObjectId("5bbffc10101248fb47295888"),
"student_id" : 2015210315, "student_name" : "张三丰", "gender" : "男" }
{ "_id" : ObjectId("5bbffc4d101248fb47295889"),
"student_id" : 2015210316, "student_name" : "李想", "gender" : "男" }
{ "_id" : 2015210317, "student_name" : "郭涛", "gender" : "男" }
```
此外，findAndModify()也可以用于插入文档，但是前提是所需插入的文档在集合中不存在，如果存在了就变成更新了。如果只是插入操作不要使用这种方式了，findAndModify()一般用于更新或删除操作。

## 6.查询文档
MongoDB 查询文档使用 find(), findOne(), findMany()等方法。
#### find()
MongoDB 查询数据的语法格式如下：
```javascript
db.collection.find(query, projection)
```
- query ：可选，使用查询操作符指定查询条件，类型为BJSON。若查询时返回文档中所有键值，只需省略该参数即可（默认省略）。
- projection ：可选，使用投影操作符指定返回的键，参数类型为BJSON。`{field1: value1, field2: value2,...}`，value的取值是可以为true/false或者1/0。若查询时返回文档中所有键值，只需省略该参数即可（默认省略）。

如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下： `db.col.find().pretty()`

<B> 例10 查看student集合中的所有文档</B>
```javascript
> db.student.find().pretty()
{
	"_id" : ObjectId("5bc164f3a0c3608258688579"),
	"student_id" : 2015210315,
	"student_name" : "张三丰",
	"gender" : "男"
}
{
	"_id" : ObjectId("5bc164f3a0c360825868857a"),
	"student_id" : 2015210316,
	"student_name" : "李想",
	"gender" : "男"
}
{ "_id" : 2015210317, "student_name" : "郭涛", "gender" : "男" }
```
从例10中可以发现，如果不传递query和projection参数，则返回集合中的所有文档。可以通过传递一个文档给query，用以定义查询条件（返回行）；也可以通过传递一个文档给projection，用以定义返回的键值对（返回列）。

<B> 例11 查看student集合中student_id为2015210315的文档。</B>
```javascript
> db.student.find({'student_id':2015210315}).pretty()
{
	"_id" : ObjectId("5bc164f3a0c3608258688579"),
	"student_id" : 2015210315,
	"student_name" : "张三丰",
	"gender" : "男"
}
> db.student.find({}, {_id:0, student_name:1}).pretty()
{ "student_name" : "张三丰" }
{ "student_name" : "李想" }
{ "student_name" : "郭涛" }
```
除了定义等值比较条件之外，也可以定义其它类型的筛选条件，如下表。

| 操作     | 格式     |范例     |SQL     |
| :------------- | :------------- |:------------- |:------------- |
| 等于       | {key:value} |db.collection_name.find({"name":"张三"}) |where name = '张三' |
|小于 |{key:{$lt:value}} |db.collection_name.find({"height":{$lt:173}})|where height < 173|
|小于等于 |{key:{$lte:value}} |db.collection_name.find({"height":{$lte:173}})|where height <= 173|
|大于 |{key:{$gt:value}} |db.collection_name.find({"height":{$gt:173}})|where height > 173|
|大于等于 |{key:{$gte:value}} |db.collection_name.find({"height":{$gte:173}})|where height >= 173|
|不等于 |{key:{$ne:value}} |db.collection_name.find({"height":{$ne:173}})|where height != 173|
|in：出现在array |{ket:{$in:value}}|db.collection_name.find({"奖学金":{$in:'国家奖学金'}} |NA|
|nin：未出现在array |{ket:{$nin:value} |db.collection_name.find({"奖学金":{$nin:'国家奖学金'}} |NA|

find()方法的query参数可以传入多个键(key)，每个键(key)以逗号隔开，即对应 SQL 的复合子句；此外，如果在一个键上也可以定义多个条件，例如: 身高在173和180之间的文档集合，对应查询`db.student.find({height: {$lte:180, $gte:180}})`。

如果文档的域的值为一个数组，且查询为复合条件，只要数组中有符合符合条件的元素，则会返回该文档。
```javascript
> var x = [{ "_id" : 1, "score" : [ -1, 3 ] },
... { "_id" : 2, "score" : [ 1, 5 ] },
... { "_id" : 3, "score" : [ 5, 5 ] }]
> db.student.insertMany(x)
{ "acknowledged" : true, "insertedIds" : [ 1, 2, 3 ] }
> db.student.find({score:{$gt:0, $lt:2}})
{ "_id" : 1, "score" : [ -1, 3 ] }
{ "_id" : 2, "score" : [ 1, 5 ] }
```
因为_id为3的score域中不存在大于0且小于2的元素，所以不包含查询结果之中。

#### projection
projection定义了查询结果集需要返回的键值对，相当于select语句后跟的字段。如果该参数缺省，则返回所有的键值对，相当于`select * from <tb_name> where ...`

<b>例12 查看student集合中所有学生的姓名与性别. </b>
```javascript
> db.student.find({},{_id:false, student_name:true, gender:true}).pretty()
{ "student_name" : "张三丰", "gender" : "男" }
{ "student_name" : "李想", "gender" : "男" }
{ "student_name" : "郭涛", "gender" : "男" }
{ }
{ }
{ }
```
例12中，界定了不返回_id键值对，返回所有文档的student_name和gender。


## 7.更新文档
MongoDB 使用 update() 和 save() 方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。

#### update()
update() 方法用于更新已存在的文档。语法格式如下：
```javascript
db.<collection_name>.update(
   <query>,
   <update>,
   {
     upsert: <boolean>,
     multi: <boolean>,
     writeConcern: <document>
   }
)
```
>参数说明：
- query : update的查询条件，类似sql update查询内where子句。
- update : update的对象和一些更新的操作符（如$,$inc...）等，也可以理解为sql update查询内set子句
- upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,　**true为插入，默认是false，不插入**。
- multi : 可选，mongodb 默认是false,只更新找到的第1条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。
- writeConcern :可选，抛出异常的级别。


<B> 例13 将student_name为李想的文档的gender更新为女.</B>
```javascript
> db.student.update({'student_name':'李想'},
    {$set:{'gender':'女'}})
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
> db.student.find({'student_name':'李想'})
{ "_id" : ObjectId("5bbffc4d101248fb47295889"),
"student_id" : 2015210316, "student_name" : "李想", "gender" : "女" }
>
```
注意：以上语句只会修改被查询到的第一个文档，如果你要修改满足查询条件的文档，则需要设置 multi 参数为 true。

#### 补充知识点：查询条件包含内嵌文档内容

<b> Query for an Array Element </b>

The following operation returns documents in the bios collection where the array field contribs contains the element "UNIX":
```javascript
> db.bios.find( { contribs: "UNIX" } ).pretty()
{
	"_id" : ObjectId("5bc2c251ff946f74224f57e0"),
	"name" : {
		"first" : "Dennis",
		"last" : "Ritchie"
	},
	"birth" : ISODate("1941-09-09T04:00:00Z"),
	"death" : ISODate("2011-10-12T04:00:00Z"),
	"contribs" : [
		"UNIX",
		"C"
	],
	"awards" : [
		{
			"award" : "Turing Award",
			"year" : 1983,
			"by" : "ACM"
		},
		{
			"award" : "National Medal of Technology",
			"year" : 1998,
			"by" : "United States"
		},
		{
			"award" : "Japan Prize",
			"year" : 2011,
			"by" : "The Japan Prize Foundation"
		}
	]
}
```
<b>Query an Array of Documents</b>

The following operation returns documents in the bios collection where awards array contains an embedded document element that contains the award field equal to "Turing Award" and the year field greater than 1980:
```javascript
> db.bios.find({awards:{$elemMatch:{award:"Turing Award", year: {$gt: 1980}}}}).pretty()
{
	"_id" : 4,
	"name" : {
		"first" : "Kristen",
		"last" : "Nygaard"
	},
	"birth" : ISODate("1926-08-27T04:00:00Z"),
	"death" : ISODate("2002-08-10T04:00:00Z"),
	"contribs" : [
		"OOP",
		"Simula"
	],
	"awards" : [
		{
			"award" : "Rosing Prize",
			"year" : 1999,
			"by" : "Norwegian Data Association"
		},
		{
			"award" : "Turing Award",
			"year" : 2001,
			"by" : "ACM"
		},
		{
			"award" : "IEEE John von Neumann Medal",
			"year" : 2001,
			"by" : "IEEE"
		}
	]
}
{
	"_id" : 5,
	"name" : {
		"first" : "Ole-Johan",
		"last" : "Dahl"
	},
	"birth" : ISODate("1931-10-12T04:00:00Z"),
	"death" : ISODate("2002-06-29T04:00:00Z"),
	"contribs" : [
		"OOP",
		"Simula"
	],
	"awards" : [
		{
			"award" : "Rosing Prize",
			"year" : 1999,
			"by" : "Norwegian Data Association"
		},
		{
			"award" : "Turing Award",
			"year" : 2001,
			"by" : "ACM"
		},
		{
			"award" : "IEEE John von Neumann Medal",
			"year" : 2001,
			"by" : "IEEE"
		}
	]
}
{
	"_id" : ObjectId("5bc2c251ff946f74224f57e0"),
	"name" : {
		"first" : "Dennis",
		"last" : "Ritchie"
	},
	"birth" : ISODate("1941-09-09T04:00:00Z"),
	"death" : ISODate("2011-10-12T04:00:00Z"),
	"contribs" : [
		"UNIX",
		"C"
	],
	"awards" : [
		{
			"award" : "Turing Award",
			"year" : 1983,
			"by" : "ACM"
		},
		{
			"award" : "National Medal of Technology",
			"year" : 1998,
			"by" : "United States"
		},
		{
			"award" : "Japan Prize",
			"year" : 2011,
			"by" : "The Japan Prize Foundation"
		}
	]
}
>
```

<b> Query Embedded Documents </b>

<b>Query Exact Matches on Embedded Documents</b>

The following operation returns documents in the bios collection where the embedded document name is exactly `{ first: "Yukihiro", last: "Matsumoto" }`, including the order:
```javascript
> db.bios.find(
    {
      name: {
              first: "Yukihiro",
              last: "Matsumoto"
            }
    }
)
>
```
The name field must match the embedded document exactly. The query does not match documents with the following name fields:
```javascript
{
   first: "Yukihiro",
   aka: "Matz",
   last: "Matsumoto"
}
```
<b> Query Fields of an Embedded Document </b>

The following operation returns documents in the bios collection where the embedded document name contains a field first with the value "Yukihiro" and a field last with the value "Matsumoto". The query uses dot notation to access fields in an embedded document:
```javascript
> db.bios.find(
... {"name.first":"Yukihiro",
... "name.last":"Matsumoto"}).pretty()
{
	"_id" : 8,
	"name" : {
		"first" : "Yukihiro",
		"aka" : "Matz",
		"last" : "Matsumoto"
	},
	"birth" : ISODate("1965-04-14T04:00:00Z"),
	"contribs" : [
		"Ruby"
	],
	"awards" : [
		{
			"award" : "Award for the Advancement of Free Software",
			"year" : "2011",
			"by" : "Free Software Foundation"
		}
	]
}

```
The query matches the document where the name field contains an embedded document with the field first with the value "Yukihiro" and a field last with the value "Matsumoto". For instance, the query would match documents with name fields that held either of the following values:
```javascript
{
  first: "Yukihiro",
  aka: "Matz",
  last: "Matsumoto"
}

```

### 附: Bios集合
```javascript
{
    "_id" : 1,
    "name" : {
        "first" : "John",
        "last" : "Backus"
    },
    "birth" : ISODate("1924-12-03T05:00:00Z"),
    "death" : ISODate("2007-03-17T04:00:00Z"),
    "contribs" : [
        "Fortran",
        "ALGOL",
        "Backus-Naur Form",
        "FP"
    ],
    "awards" : [
        {
            "award" : "W.W. McDowell Award",
            "year" : 1967,
            "by" : "IEEE Computer Society"
        },
        {
            "award" : "National Medal of Science",
            "year" : 1975,
            "by" : "National Science Foundation"
        },
        {
            "award" : "Turing Award",
            "year" : 1977,
            "by" : "ACM"
        },
        {
            "award" : "Draper Prize",
            "year" : 1993,
            "by" : "National Academy of Engineering"
        }
    ]
}

{
    "_id" : ObjectId("51df07b094c6acd67e492f41"),
    "name" : {
        "first" : "John",
        "last" : "McCarthy"
    },
    "birth" : ISODate("1927-09-04T04:00:00Z"),
    "death" : ISODate("2011-12-24T05:00:00Z"),
    "contribs" : [
        "Lisp",
        "Artificial Intelligence",
        "ALGOL"
    ],
    "awards" : [
        {
            "award" : "Turing Award",
            "year" : 1971,
            "by" : "ACM"
        },
        {
            "award" : "Kyoto Prize",
            "year" : 1988,
            "by" : "Inamori Foundation"
        },
        {
            "award" : "National Medal of Science",
            "year" : 1990,
            "by" : "National Science Foundation"
        }
    ]
}

{
    "_id" : 3,
    "name" : {
        "first" : "Grace",
        "last" : "Hopper"
    },
    "title" : "Rear Admiral",
    "birth" : ISODate("1906-12-09T05:00:00Z"),
    "death" : ISODate("1992-01-01T05:00:00Z"),
    "contribs" : [
        "UNIVAC",
        "compiler",
        "FLOW-MATIC",
        "COBOL"
    ],
    "awards" : [
        {
            "award" : "Computer Sciences Man of the Year",
            "year" : 1969,
            "by" : "Data Processing Management Association"
        },
        {
            "award" : "Distinguished Fellow",
            "year" : 1973,
            "by" : " British Computer Society"
        },
        {
            "award" : "W. W. McDowell Award",
            "year" : 1976,
            "by" : "IEEE Computer Society"
        },
        {
            "award" : "National Medal of Technology",
            "year" : 1991,
            "by" : "United States"
        }
    ]
}

{
    "_id" : 4,
    "name" : {
        "first" : "Kristen",
        "last" : "Nygaard"
    },
    "birth" : ISODate("1926-08-27T04:00:00Z"),
    "death" : ISODate("2002-08-10T04:00:00Z"),
    "contribs" : [
        "OOP",
        "Simula"
    ],
    "awards" : [
        {
            "award" : "Rosing Prize",
            "year" : 1999,
            "by" : "Norwegian Data Association"
        },
        {
            "award" : "Turing Award",
            "year" : 2001,
            "by" : "ACM"
        },
        {
            "award" : "IEEE John von Neumann Medal",
            "year" : 2001,
            "by" : "IEEE"
        }
    ]
}

{
    "_id" : 5,
    "name" : {
        "first" : "Ole-Johan",
        "last" : "Dahl"
    },
    "birth" : ISODate("1931-10-12T04:00:00Z"),
    "death" : ISODate("2002-06-29T04:00:00Z"),
    "contribs" : [
        "OOP",
        "Simula"
    ],
    "awards" : [
        {
            "award" : "Rosing Prize",
            "year" : 1999,
            "by" : "Norwegian Data Association"
        },
        {
            "award" : "Turing Award",
            "year" : 2001,
            "by" : "ACM"
        },
        {
            "award" : "IEEE John von Neumann Medal",
            "year" : 2001,
            "by" : "IEEE"
        }
    ]
}

{
    "_id" : 6,
    "name" : {
        "first" : "Guido",
        "last" : "van Rossum"
    },
    "birth" : ISODate("1956-01-31T05:00:00Z"),
    "contribs" : [
        "Python"
    ],
    "awards" : [
        {
            "award" : "Award for the Advancement of Free Software",
            "year" : 2001,
            "by" : "Free Software Foundation"
        },
        {
            "award" : "NLUUG Award",
            "year" : 2003,
            "by" : "NLUUG"
        }
    ]
}

{
    "_id" : ObjectId("51e062189c6ae665454e301d"),
    "name" : {
        "first" : "Dennis",
        "last" : "Ritchie"
    },
    "birth" : ISODate("1941-09-09T04:00:00Z"),
    "death" : ISODate("2011-10-12T04:00:00Z"),
    "contribs" : [
        "UNIX",
        "C"
    ],
    "awards" : [
        {
            "award" : "Turing Award",
            "year" : 1983,
            "by" : "ACM"
        },
        {
            "award" : "National Medal of Technology",
            "year" : 1998,
            "by" : "United States"
        },
        {
            "award" : "Japan Prize",
            "year" : 2011,
            "by" : "The Japan Prize Foundation"
        }
    ]
}

{
    "_id" : 8,
    "name" : {
        "first" : "Yukihiro",
        "aka" : "Matz",
        "last" : "Matsumoto"
    },
    "birth" : ISODate("1965-04-14T04:00:00Z"),
    "contribs" : [
        "Ruby"
    ],
    "awards" : [
        {
            "award" : "Award for the Advancement of Free Software",
            "year" : "2011",
            "by" : "Free Software Foundation"
        }
    ]
}

{
    "_id" : 9,
    "name" : {
        "first" : "James",
        "last" : "Gosling"
    },
    "birth" : ISODate("1955-05-19T04:00:00Z"),
    "contribs" : [
        "Java"
    ],
    "awards" : [
        {
            "award" : "The Economist Innovation Award",
            "year" : 2002,
            "by" : "The Economist"
        },
        {
            "award" : "Officer of the Order of Canada",
            "year" : 2007,
            "by" : "Canada"
        }
    ]
}

{
    "_id" : 10,
    "name" : {
        "first" : "Martin",
        "last" : "Odersky"
    },
    "contribs" : [
        "Scala"
    ]
}
```
